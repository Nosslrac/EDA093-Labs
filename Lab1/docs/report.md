Lab 1 

Lab group: 9 

## Specifications 
The implementation of this code does indeed pass all the requirements stated in the specification part of the README file for lab 1 as shown in figure 1 in Appendix. This section outlines the requirements that were met in the implemented lsh-shell. 
The lsh shell can successfully respond to the ctr-D command by interpreting the parsed line-input as a null char object and exit the shell terminal and printing “detected EOF” End-Of-File. The lsh shell is capable of handling several simple commands that are executable in a normal bash terminal such as “ls”, “date”, and “who”. The current path environment is saved in a variable, additionally part of this path, the last two directories, is shown in the lsh shell as shown in figure 2 Appendix. The shell also supports running operations in the background, meaning that a different process handles the operation without disturbing or blocking the shell from executing additional commands. Furthermore, the shell implement piping function which was relatively the most difficult one to implement. For instance, the command “ls | grep out | wc -w “consists of three commands in total and should be executed dependently of each other, meaning that the first command directs its output to the second command and so on. The shell can also read from or write to an external file, known as I/O Redirection. This is done by dealing with symbol “<” or “>”. Moreover, the shell can change the directory using the “cd” command and “exit”. Finally, the ctr-C command is implemented so that it only terminates the current foreground process and not the shell itself, meaning that it shouldn’t affect any background jobs. All these commands and executions are handled in a way that it doesn’t leave zombies behind, meaning that a child is never left by its parent. The implemented lsh-shell doesn’t invoke any system calls from the outer terminal such as bash or sh. 

## In which order? 
The first functionalities of the shell to be implemented were Ctrl-D handling, basic commands (which were later extended to handle I/O, piping etc.) and implementing cd and exit. 
To check for Ctrl-D from the user, check for EOF signal and simply end process using SIGHUP signal. 
For cd and exit, two helper functions were created to check if "cd ..." or "exit" is received from the user. When receiving input from the user, and it is not EOF, check for exit command (exit also terminates running child processes). If there is none, then check if command includes cd (execute command and change directory). If the command is neither, continue process to handle the user input.
Before the process handles basic commands, it forks and makes the new child execute the command. The new process checks if the command is either read or write for a file (check for rstdout and rstdin). If so, the process handles these using open(), dup2() and STDOUT_FILENO/STDIN_FILENO. For commands that do not interact with other files directly the process starts piping.
This is also where background execution was implemented. If the process is the parent and the command executed by the child is a foreground process, then wait for the process to terminate before continuing.
A function called forkAndPipe() is called when the child starts to handle the given command. It takes in both the struct for the command and the previous pipe, but also the number of forks that should be created. This is calculated by traversing and calculating the length of the pgm linked list from the command struct and subract one (do not need to create a pipe for last in the pipeline). If the process does not need to fork (either only one command or base case), simply execute the given command. If the process needs to fork, it will do so recursively while both execute a command given to a child and forward the result using. Forwarding is done by closing either the read or write end of its pipe and redirecting STD(OUT/IN)_FILENO using dup2().
The process also handles signals SIGINT and SIGCHLD. If SIGINT is called (CTRL+C), the process closes all foreground processes. If SIGCHLD is called, the process terminates background processes after they have finished. Both signal handlers check waitpid using WNOHANG (without suspending the program).

## Challenges
An issue with our first implementation was that our shell only waits for the last child process in the pipe. Since the processes were created in a cascading fashion and we start our commands with ```execvp```, there is no resonable way of making the child processes wait for its children. This means that if the last command finishes the shell prompt will reappear but another process might still be using ```stdout```, leading to weird behavior in this case until Ctrl-C is pressed. For example, ```grep apa | ls``` would appear to finish, the prompt reappeared but new commands would display strange behavior if the shell even displayed the text you wrote. When you pressed Ctrl-C the normal behavior would resume, but this was generally very unintuitive behavior. To resolve this issue we realized that the way we created the processes, in cascading fashion, made it impossible to wait for all grandchild processes. Thus, we decided fork all processes from the shell process. However, forking all processes from the shell process made the setup of the pipes a lot uglier. Since all pipes are created in the shell process and one process might need two different pipes, one to read from and one to write to, we need two pipes available instead of one as in our recursive implementation.

## Feedback
The automatic test used for this lab looks to include tests that cover most of the requirements for having a working shell (in the capacity that is the lab). It was also a nice check to have during development, as you could use it as a sort of checklist or milestone checker that shows you have made progress. As the FAQ for this lab explain, it it also necessary to perform manual tests to catch potential issues not caught by the automatic test. One such test, the "grep apa | ls" from the same FAQ document, is a test that seems quite important. A suggestion is to either create a automatic test for this, or if not possible, highlight its importance in the README for the labs repository.
