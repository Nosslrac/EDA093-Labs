Lab 1 Lab group: 9 Members:

Have you met all specifications outlined? ...

**In which order?** 
The first functionalities of the shell to be implemented were Ctrl-D handling, basic commands (which were later extended to handle I/O, piping etc.) and implementing cd and exit. 
To check for Ctrl-D from the user, check for EOF signal and simply end process using SIGHUP signal. 
For cd and exit, two helper functions were created to check if "cd ..." or "exit" is received from the user. When receiving input from the user, and it is not EOF, check for exit command (exit also terminates running child processes). If there is none, then check if command includes cd (execute command and change directory). If the command is neither, continue process to handle the user input.
Before the process handles basic commands, it forks and makes the new child execute the command. The new process checks if the command is either read or write for a file (check for rstdout and rstdin). If so, the process handles these using open(), dup2() and STDOUT_FILENO/STDIN_FILENO. For commands that do not interact with other files directly the process starts piping.
This is also where background execution was implemented. If the process is the parent and the command executed by the child is a foreground process, then wait for the process to terminate before continuing.
A function called forkAndPipe() is called when the child starts to handle the given command. It takes in both the struct for the command and the previous pipe, but also the number of forks that should be created. This is calculated by traversing and calculating the length of the pgm linked list from the command struct and subract one (do not need to create a pipe for last in the pipeline). If the process does not need to fork (either only one command or base case), simply execute the given command. If the process needs to fork, it will do so recursively while both execute a command given to a child and forward the result using. Forwarding is done by closing either the read or write end of its pipe and redirecting STD(OUT/IN)_FILENO using dup2().
The process also handles signals SIGINT and SIGCHLD. If SIGINT is called (CTRL+C), the process closes all foreground processes. If SIGCHLD is called, the process terminates background processes after they have finished. Both signal handlers check waitpid using WNOHANG (without suspending the program).

What challenges did you encounter for each specification? One of the biggest challenges was to simply understand and make use of functions, signals, inputs etc. from different used code libraries. These are what makes this lab possible, but it can sometimes be a bit of trail and error when trying to find a good solution to a problem

**Feedback**
The automatic test used for this lab looks to include tests that cover most of the requirements for having a working shell (in the capacity that is the lab). It was also a nice check to have during development, as you could use it as a sort of checklist or milestone checker that shows you have made progress. As the FAQ for this lab explain, it it also necessary to perform manual tests to catch potential issues not caught by the automatic test. One such test, the "grep apa | ls" from the same FAQ document, is a test that seems quite important. A suggestion is to either create a automatic test for this, or if not possible, highlight its importance in the README for the labs repository.

## Challenges
An issue with our first implementation was that our shell only waits for the last child process in the pipe. Since the processes were created in a cascading fashion and we start our commands with ```execvp```, there is no resonable way of making the child processes wait for its children. This means that if the last command finishes the shell prompt will reappear but another process might still be using ```stdout```, leading to weird behavior in this case until Ctrl-C is pressed. For example, ```grep apa | ls``` would appear to finish, the prompt reappeared but new commands would display strange behavior if the shell even displayed the text you wrote. When you pressed Ctrl-C the normal behavior would resume, but this was generally very unintuitive behavior. To resolve this issue we realized that the way we created the processes, in cascading fashion, made it impossible to wait for all grandchild processes. Thus, we decided fork all processes from the shell process. However, forking all processes from the shell process made the setup of the pipes a lot uglier. Since all pipes are created in the shell process and one process might need two different pipes, one to read from and one to write to, we need two pipes available instead of one as in our recursive implementation.

**Biggest problem:**
